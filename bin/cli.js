#!/usr/bin/env node

/**
 * @fileoverview Universal Emoji Cleaner - CLI Tool
 * @author Chahuadev
 * @version 2.1.0
 * 
 * Command Line Interface for Emoji Cleaner
 * ‡∏ï‡∏±‡∏ß‡∏•‡∏ö‡∏≠‡∏¥‡πÇ‡∏°‡∏à‡∏¥‡∏™‡∏≤‡∏Å‡∏• ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏ú‡πà‡∏≤‡∏ô Command Line
 */

const fs = require('fs');
const path = require('path');
const { processFile, processDirectory } = require('../src/index');

/**
 * ‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô
 */
function showHelp() {
    console.log(`
üìñ Universal Emoji Cleaner v2.1.0 - Usage Guide

SYNTAX:
  emoji-cleaner [target] [options]
  npx @chahuadev/emoji-cleaner [target] [options]

ARGUMENTS:
  target                Path to file or directory (default: current directory)

OPTIONS:
  -d, --dry-run        Preview changes without modifying files
  -v, --verbose        Show detailed information during processing
  -b, --backup         Create backup before making changes
  -e, --extensions     File extensions to process (default: js,ts,jsx,tsx,html)
  -x, --exclude        Directories to exclude (default: node_modules,.git,dist,build)
  -h, --help           Show this help message
  --version            Show version information

EXAMPLES:
  emoji-cleaner                          # Clean current directory
  emoji-cleaner ./src                    # Clean specific directory
  emoji-cleaner file.js                  # Clean specific file
  emoji-cleaner . --dry-run             # Preview changes
  emoji-cleaner . --backup              # Create backup before cleaning
  emoji-cleaner . -e js,ts,html         # Process only specific extensions
  emoji-cleaner . -x node_modules,dist  # Exclude specific directories

SUPPORTED FILES:
  ‚úÖ JavaScript (.js, .jsx)
  ‚úÖ TypeScript (.ts, .tsx) 
  ‚úÖ HTML (.html)
  ‚úÖ And more text-based files

FEATURES:
  üßπ Remove emojis from code and text
  üó®Ô∏è  Remove emoji-only comments
  üíæ Optional backup before changes
  üîç Dry-run mode for preview
  üìä Detailed statistics and reporting
  üöÄ Fast processing of large codebases

For more information, visit: https://github.com/chahuadev/emoji-cleaner
`);
}

/**
 * ‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏ß‡∏≠‡∏£‡πå‡∏ä‡∏±‡∏ô
 */
function showVersion() {
    const packagePath = path.join(__dirname, '..', 'package.json');
    try {
        const packageInfo = JSON.parse(fs.readFileSync(packagePath, 'utf8'));
        console.log(`üßπ Universal Emoji Cleaner v${packageInfo.version}`);
        console.log(`üì¶ npm package: ${packageInfo.name}`);
        console.log(`üë®‚Äçüíª Author: ${packageInfo.author.name}`);
        console.log(`üîó Repository: ${packageInfo.repository.url}`);
    } catch (error) {
        console.log('üßπ Universal Emoji Cleaner v2.1.0');
    }
}

/**
 * Parse command line arguments
 */
function parseArguments(args) {
    const options = {
        target: process.cwd(),
        dryRun: false,
        verbose: false,
        backup: false,
        extensions: ['.js', '.ts', '.jsx', '.tsx', '.html'],
        excludeDirs: ['node_modules', '.git', 'dist', 'build', 'coverage'],
        help: false,
        version: false
    };

    for (let i = 0; i < args.length; i++) {
        const arg = args[i];

        if (arg === '-h' || arg === '--help') {
            options.help = true;
        } else if (arg === '--version') {
            options.version = true;
        } else if (arg === '-d' || arg === '--dry-run') {
            options.dryRun = true;
        } else if (arg === '-v' || arg === '--verbose') {
            options.verbose = true;
        } else if (arg === '-b' || arg === '--backup') {
            options.backup = true;
        } else if (arg === '-e' || arg === '--extensions') {
            if (i + 1 < args.length) {
                const exts = args[i + 1].split(',').map(ext => ext.trim().startsWith('.') ? ext.trim() : '.' + ext.trim());
                options.extensions = exts;
                i++;
            }
        } else if (arg === '-x' || arg === '--exclude') {
            if (i + 1 < args.length) {
                options.excludeDirs = args[i + 1].split(',').map(dir => dir.trim());
                i++;
            }
        } else if (!arg.startsWith('-')) {
            // This is the target path
            options.target = path.resolve(arg);
        }
    }

    return options;
}

/**
 * ‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÑ‡∏ü‡∏•‡πå‡πÄ‡∏î‡∏µ‡∏¢‡∏ß
 */
function displayFileResult(result, options) {
    const fileName = path.basename(result.filePath);
    const relativePath = path.relative(process.cwd(), result.filePath);

    if (result.success) {
        if (result.changed) {
            const icon = options.dryRun ? 'üîç' : '‚úÖ';
            console.log(`${icon} ${relativePath}`);
            if (options.verbose) {
                console.log(`   üìù Emojis removed: ${result.emojiCount}`);
                console.log(`   üí¨ Comments cleaned: ${result.commentCount}`);
                console.log(`   üìè Size: ${result.originalSize} ‚Üí ${result.newSize} bytes`);
            } else {
                console.log(`   ${result.emojiCount} emojis, ${result.commentCount} comments`);
            }
        } else if (options.verbose) {
            console.log(`‚ú® ${relativePath} - No emojis found`);
        }
    } else {
        console.log(`‚ùå ${relativePath} - Error: ${result.error}`);
    }
}

/**
 * ‡πÅ‡∏™‡∏î‡∏á‡∏™‡∏ñ‡∏¥‡∏ï‡∏¥‡∏£‡∏ß‡∏°
 */
function displaySummary(stats, options) {
    console.log(`\nüìä Summary:`);
    console.log(`   üìÅ Files processed: ${stats.totalFiles}`);
    console.log(`   üîÑ Files with changes: ${stats.filesWithChanges}`);
    console.log(`   üßπ Total emojis removed: ${stats.totalEmojis}`);
    console.log(`   üí¨ Total comments cleaned: ${stats.totalComments}`);
    console.log(`   ‚è±Ô∏è  Processing time: ${stats.duration}s`);

    if (stats.errors > 0) {
        console.log(`   ‚ö†Ô∏è  Errors: ${stats.errors}`);
    }

    if (stats.backupDir) {
        console.log(`   üíæ Backup directory: ${path.relative(process.cwd(), stats.backupDir)}`);
    }

    if (options.dryRun) {
        console.log(`\nüîç Dry-run completed. Use without --dry-run to apply changes.`);
    } else if (stats.filesWithChanges > 0) {
        console.log(`\n‚úÖ Cleaning completed successfully!`);
    } else {
        console.log(`\n‚ú® No emojis found in processed files.`);
    }
}

/**
 * Main CLI function
 */
async function main() {
    const args = process.argv.slice(2);
    const options = parseArguments(args);

    // Show help or version
    if (options.help) {
        showHelp();
        return;
    }

    if (options.version) {
        showVersion();
        return;
    }

    // Check if target exists
    if (!fs.existsSync(options.target)) {
        console.error(`‚ùå Error: Target path does not exist: ${options.target}`);
        process.exit(1);
    }

    const stat = fs.statSync(options.target);

    try {
        if (stat.isFile()) {
            // Process single file
            console.log(`üîß Processing file: ${path.relative(process.cwd(), options.target)}`);

            const result = processFile(options.target, {
                dryRun: options.dryRun,
                createBackup: options.backup
            });

            displayFileResult(result, options);

            if (!result.success) {
                process.exit(1);
            }

        } else if (stat.isDirectory()) {
            // Process directory
            console.log(`üîß Processing directory: ${path.relative(process.cwd(), options.target)}`);
            if (options.dryRun) {
                console.log(`üîç Dry-run mode: previewing changes...`);
            }
            console.log(`üìÅ Extensions: ${options.extensions.join(', ')}`);
            console.log(`üö´ Excluding: ${options.excludeDirs.join(', ')}`);
            console.log('');

            const stats = processDirectory(options.target, {
                dryRun: options.dryRun,
                extensions: options.extensions,
                createBackup: options.backup,
                excludeDirs: options.excludeDirs
            });

            // Display individual file results if verbose
            if (options.verbose) {
                stats.results.forEach(result => {
                    displayFileResult(result, options);
                });
            } else {
                // Display only files with changes
                stats.results.filter(r => r.changed).forEach(result => {
                    displayFileResult(result, options);
                });
            }

            displaySummary(stats, options);

            if (stats.errors > 0) {
                process.exit(1);
            }
        }

    } catch (error) {
        console.error(`‚ùå Error: ${error.message}`);
        process.exit(1);
    }
}

// Run CLI if this file is executed directly
if (require.main === module) {
    main().catch(error => {
        console.error(`‚ùå Unexpected error: ${error.message}`);
        process.exit(1);
    });
}

module.exports = { main, parseArguments, showHelp, showVersion };