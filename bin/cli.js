#!/usr/bin/env node

/**
 * @fileoverview Universal Emoji Cleaner - CLI Tool
 * @author Chahuadev
 * @version 2.2.3
 * 
 * Command Line Interface for Emoji Cleaner with Enhanced Security
 * ‡∏ï‡∏±‡∏ß‡∏•‡∏ö‡∏≠‡∏¥‡πÇ‡∏°‡∏à‡∏¥‡∏™‡∏≤‡∏Å‡∏• ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏ú‡πà‡∏≤‡∏ô Command Line ‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏£‡∏∞‡∏ö‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡∏õ‡∏•‡∏≠‡∏î‡∏†‡∏±‡∏¢‡∏Ç‡∏±‡πâ‡∏ô‡∏™‡∏π‡∏á
 */

const fs = require('fs');
const path = require('path');

// ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÉ‡∏ä‡πâ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏à‡∏≤‡∏Å main file ‡∏ó‡∏µ‡πà‡∏°‡∏µ security features
const emojiCleaner = require('../emoji-cleaner');

// ‡πÉ‡∏ä‡πâ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏à‡∏≤‡∏Å main file ‡πÅ‡∏ó‡∏ô
const processFile = emojiCleaner.processFile || emojiCleaner.analyzeFile;
const processDirectory = emojiCleaner.processDirectory;

/**
 * ‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô
 */
function showHelp() {
    console.log(`
üìñ Universal Emoji Cleaner v2.2.3 - Usage Guide

SYNTAX:
  emoji-cleaner [target] [options]
  npx @chahuadev/emoji-cleaner [target] [options]

ARGUMENTS:
  target                Path to file or directory (default: current directory)

OPTIONS:
  -d, --dry-run        Preview changes without modifying files
  -v, --verbose        Show detailed information during processing
  -b, --backup         Create backup before making changes
  -e, --extensions     File extensions to process (default: js,ts,jsx,tsx,html)
  -x, --exclude        Directories to exclude (default: node_modules,.git,dist,build)
  -h, --help           Show this help message
  --version            Show version information

EXAMPLES:
  emoji-cleaner                          # Clean current directory
  emoji-cleaner ./src                    # Clean specific directory
  emoji-cleaner file.js                  # Clean specific file
  emoji-cleaner . --dry-run             # Preview changes
  emoji-cleaner . --backup              # Create backup before cleaning
  emoji-cleaner . -e js,ts,html         # Process only specific extensions
  emoji-cleaner . -x node_modules,dist  # Exclude specific directories

SUPPORTED FILES:
  ‚úÖ JavaScript (.js, .jsx)
  ‚úÖ TypeScript (.ts, .tsx) 
  ‚úÖ HTML (.html)
  ‚úÖ And more text-based files

FEATURES:
  üßπ Remove emojis from code and text
  üó®Ô∏è  Remove emoji-only comments
  üíæ Optional backup before changes
  üîç Dry-run mode for preview
  üìä Detailed statistics and reporting
  üöÄ Fast processing of large codebases

For more information, visit: https://github.com/chahuadev/emoji-cleaner
`);
}

/**
 * ‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏ß‡∏≠‡∏£‡πå‡∏ä‡∏±‡∏ô
 */
function showVersion() {
    const packagePath = path.join(__dirname, '..', 'package.json');
    try {
        const packageInfo = JSON.parse(fs.readFileSync(packagePath, 'utf8'));
        console.log(`üßπ Universal Emoji Cleaner v${packageInfo.version}`);
        console.log(`üì¶ npm package: ${packageInfo.name}`);
        console.log(`üë®‚Äçüíª Author: ${packageInfo.author.name}`);
        console.log(`üîó Repository: ${packageInfo.repository.url}`);
    } catch (error) {
        console.log('üßπ Universal Emoji Cleaner v2.2.3');
    }
}

/**
 * Parse command line arguments
 */
function parseArguments(args) {
    const options = {
        target: process.cwd(),
        dryRun: false,
        verbose: false,
        backup: false,
        extensions: ['.js', '.ts', '.jsx', '.tsx', '.html'],
        excludeDirs: ['node_modules', '.git', 'dist', 'build', 'coverage'],
        help: false,
        version: false
    };

    for (let i = 0; i < args.length; i++) {
        const arg = args[i];

        if (arg === '-h' || arg === '--help') {
            options.help = true;
        } else if (arg === '--version') {
            options.version = true;
        } else if (arg === '-d' || arg === '--dry-run') {
            options.dryRun = true;
        } else if (arg === '-v' || arg === '--verbose') {
            options.verbose = true;
        } else if (arg === '-b' || arg === '--backup') {
            options.backup = true;
        } else if (arg === '-e' || arg === '--extensions') {
            if (i + 1 < args.length) {
                const exts = args[i + 1].split(',').map(ext => ext.trim().startsWith('.') ? ext.trim() : '.' + ext.trim());
                options.extensions = exts;
                i++;
            }
        } else if (arg === '-x' || arg === '--exclude') {
            if (i + 1 < args.length) {
                options.excludeDirs = args[i + 1].split(',').map(dir => dir.trim());
                i++;
            }
        } else if (!arg.startsWith('-')) {
            // This is the target path
            options.target = path.resolve(arg);
        }
    }

    return options;
}

/**
 * ‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÑ‡∏ü‡∏•‡πå‡πÄ‡∏î‡∏µ‡∏¢‡∏ß
 */
function displayFileResult(result, options) {
    const fileName = path.basename(result.filePath);
    const relativePath = path.relative(process.cwd(), result.filePath);

    if (result.success) {
        if (result.changed) {
            const icon = options.dryRun ? 'üîç' : '‚úÖ';
            console.log(`${icon} ${relativePath}`);
            if (options.verbose) {
                console.log(`   üìù Emojis removed: ${result.emojiCount}`);
                console.log(`   üí¨ Comments cleaned: ${result.commentCount}`);
                console.log(`   üìè Size: ${result.originalSize} ‚Üí ${result.newSize} bytes`);
            } else {
                console.log(`   ${result.emojiCount} emojis, ${result.commentCount} comments`);
            }
        } else if (options.verbose) {
            console.log(`‚ú® ${relativePath} - No emojis found`);
        }
    } else {
        console.log(`‚ùå ${relativePath} - Error: ${result.error}`);
    }
}

/**
 * ‡πÅ‡∏™‡∏î‡∏á‡∏™‡∏ñ‡∏¥‡∏ï‡∏¥‡∏£‡∏ß‡∏°
 */
function displaySummary(stats, options) {
    console.log(`\nüìä Summary:`);
    console.log(`   üìÅ Files processed: ${stats.totalFiles}`);
    console.log(`   üîÑ Files with changes: ${stats.filesWithChanges}`);
    console.log(`   üßπ Total emojis removed: ${stats.totalEmojis}`);
    console.log(`   üí¨ Total comments cleaned: ${stats.totalComments}`);
    console.log(`   ‚è±Ô∏è  Processing time: ${stats.duration}s`);

    if (stats.errors > 0) {
        console.log(`   ‚ö†Ô∏è  Errors: ${stats.errors}`);
    }

    if (stats.backupDir) {
        console.log(`   üíæ Backup directory: ${path.relative(process.cwd(), stats.backupDir)}`);
    }

    if (options.dryRun) {
        console.log(`\nüîç Dry-run completed. Use without --dry-run to apply changes.`);
    } else if (stats.filesWithChanges > 0) {
        console.log(`\n‚úÖ Cleaning completed successfully!`);
    } else {
        console.log(`\n‚ú® No emojis found in processed files.`);
    }
}

/**
 * Main CLI function with Security
 */
async function main() {
    const args = process.argv.slice(2);
    const options = parseArguments(args);

    // Show help or version
    if (options.help) {
        showHelp();
        return;
    }

    if (options.version) {
        showVersion();
        return;
    }

    console.log('üßπ Universal Emoji Cleaner v2.2.3');
    console.log('================================');
    
    if (options.dryRun) {
        console.log(' DRY RUN MODE - No files will be modified');
    }
    
    console.log(` Target: ${path.relative(process.cwd(), options.target) || '.'}`);
    console.log(` Extensions: ${options.extensions.join(', ')}`);

    try {
        const targetStats = fs.statSync(options.target);
        
        if (targetStats.isFile()) {
            // ‡πÉ‡∏ä‡πâ analyzeFile ‡∏à‡∏≤‡∏Å main emoji-cleaner.js ‡∏ó‡∏µ‡πà‡∏°‡∏µ security
            if (typeof emojiCleaner.analyzeFile === 'function') {
                console.log(' Processing single file with security checks...');
                const result = emojiCleaner.analyzeFile(options.target, options.dryRun, options.verbose, options.backup);
                
                if (result.securityError) {
                    console.log('üö® Security check failed!');
                    process.exit(1);
                }
                
                console.log('================================');
                if (options.dryRun) {
                    console.log(' Analysis Complete!');
                } else {
                    console.log(' Cleaning Complete!');
                }
                
                console.log(` Emojis ${options.dryRun ? 'found' : 'removed'}: ${result.emojiCount}`);
                console.log(` Comments ${options.dryRun ? 'found' : 'removed'}: ${result.commentCount}`);
                
            } else {
                console.error('üö® Security functions not available!');
                process.exit(1);
            }
        } else if (targetStats.isDirectory()) {
            // ‡πÉ‡∏ä‡πâ processDirectory ‡∏à‡∏≤‡∏Å main emoji-cleaner.js ‡∏ó‡∏µ‡πà‡∏°‡∏µ security  
            if (typeof emojiCleaner.processDirectory === 'function') {
                console.log(' Processing directory with security checks...');
                const result = emojiCleaner.processDirectory(options.target, options.dryRun, options.verbose, options.extensions, options.backup);
                
                if (result.securityError) {
                    console.log('üö® Security check failed!');
                    process.exit(1);
                }
                
                console.log('================================');
                if (options.dryRun) {
                    console.log(' Analysis Complete!');
                } else {
                    console.log(' Cleaning Complete!');
                }
                
                console.log(` Files processed: ${result.totalFiles}`);
                console.log(` Files with emojis: ${result.filesWithEmojis}`);
                console.log(` Total emojis ${options.dryRun ? 'found' : 'removed'}: ${result.totalEmojis}`);
                console.log(` Comments ${options.dryRun ? 'found' : 'removed'}: ${result.totalComments}`);
                
                if (result.securityErrors > 0) {
                    console.log(` üö® Security errors: ${result.securityErrors}`);
                }
                
                if (result.errors > 0) {
                    console.log(` ‚ö†Ô∏è Other errors: ${result.errors - result.securityErrors}`);
                }
                
                console.log(` ‚è±Ô∏è Time taken: ${result.duration}s`);
                
            } else {
                console.error('üö® Security functions not available!');
                process.exit(1);
            }
        }
        
        if (options.dryRun) {
            console.log('\nüí° Use without --dry-run to apply changes');
        }
        
    } catch (error) {
        if (error.message.includes('ENOENT')) {
            console.error(`‚ùå Target not found: ${options.target}`);
        } else if (error.message.includes('Permission denied') || 
                   error.message.includes('system directories') ||
                   error.message.includes('Path traversal')) {
            console.error(`üö® Security Error: ${error.message}`);
        } else {
            console.error(`‚ùå Error: ${error.message}`);
        }
        process.exit(1);
    }
}

// Run CLI if this file is executed directly
if (require.main === module) {
    main().catch(error => {
        console.error(`‚ùå Unexpected error: ${error.message}`);
        process.exit(1);
    });
}

module.exports = { main, parseArguments, showHelp, showVersion };