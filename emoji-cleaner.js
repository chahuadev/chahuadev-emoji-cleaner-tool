#!/usr/bin/env node

/**
 * @fileoverview Universal Emoji Cleaner Tool
 * @author Chahuadev
 * @version 2.0.0
 * 
 * ‡∏ï‡∏±‡∏ß‡∏•‡∏ö‡∏≠‡∏¥‡πÇ‡∏°‡∏à‡∏¥‡∏™‡∏≤‡∏Å‡∏• ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÇ‡∏õ‡∏£‡πÄ‡∏à‡πá‡∏Å‡∏ï‡πå JavaScript, TypeScript ‡πÅ‡∏•‡∏∞ HTML
 * ‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡πÑ‡∏î‡πâ‡∏Å‡∏±‡∏ö‡πÇ‡∏õ‡∏£‡πÄ‡∏à‡πá‡∏Å‡∏ï‡πå‡πÑ‡∏´‡∏ô‡∏Å‡πá‡πÑ‡∏î‡πâ‡πÇ‡∏î‡∏¢‡πÑ‡∏°‡πà‡∏à‡∏≥‡πÄ‡∏õ‡πá‡∏ô‡∏ï‡πâ‡∏≠‡∏á‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏Å‡∏±‡∏ô
 */

const fs = require('fs');
const path = require('path');

// Enhanced emoji patterns ‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö Unicode 15.0
const EMOJI_PATTERNS = [
    // Emoticons and Symbols
    /[\u{1F600}-\u{1F64F}]/gu,  // Emoticons
    /[\u{1F300}-\u{1F5FF}]/gu,  // Misc Symbols and Pictographs  
    /[\u{1F680}-\u{1F6FF}]/gu,  // Transport and Map Symbols
    /[\u{1F700}-\u{1F77F}]/gu,  // Alchemical Symbols
    /[\u{1F780}-\u{1F7FF}]/gu,  // Geometric Shapes Extended
    /[\u{1F800}-\u{1F8FF}]/gu,  // Supplemental Arrows-C
    /[\u{1F900}-\u{1F9FF}]/gu,  // Supplemental Symbols and Pictographs
    /[\u{1FA00}-\u{1FA6F}]/gu,  // Chess Symbols
    /[\u{1FA70}-\u{1FAFF}]/gu,  // Symbols and Pictographs Extended-A
    /[\u{2600}-\u{26FF}]/gu,    // Misc symbols
    /[\u{2700}-\u{27BF}]/gu,    // Dingbats
    /[\u{1F1E0}-\u{1F1FF}]/gu,  // Regional indicators (flags)
    /[\u{1F100}-\u{1F1FF}]/gu,  // Enclosed characters
    /[\u{2B00}-\u{2BFF}]/gu,    // Miscellaneous Symbols and Arrows
    /[\u{3030}]/gu,             // Wavy dash
    /[\u{303D}]/gu,             // Part alternation mark
    /[\u{3297}]/gu,             // Japanese symbol
    /[\u{3299}]/gu,             // Japanese symbol
    /[\u{FE00}-\u{FE0F}]/gu,    // Variation selectors
    /[\u{200D}]/gu,             // Zero-width joiner
    /[\u{20E3}]/gu,             // Combining enclosing keycap
];

/**
 * ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÅ‡∏•‡∏∞‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå‡∏™‡∏≥‡∏£‡∏≠‡∏á
 */
function createBackupDir(targetPath) {
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
    const backupDir = path.join(path.dirname(targetPath), `emoji-backup-${timestamp}`);
    
    if (!fs.existsSync(backupDir)) {
        fs.mkdirSync(backupDir, { recursive: true });
    }
    return backupDir;
}

/**
 * ‡∏Ñ‡∏±‡∏î‡∏•‡∏≠‡∏Å‡πÑ‡∏ü‡∏•‡πå‡πÑ‡∏õ‡∏¢‡∏±‡∏á‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå‡∏™‡∏≥‡∏£‡∏≠‡∏á
 */
function backupFile(filePath, backupDir, originalRoot) {
    try {
        const relativePath = path.relative(originalRoot, filePath);
        const backupFilePath = path.join(backupDir, relativePath);
        const backupFileDir = path.dirname(backupFilePath);
        
        // ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå‡∏™‡∏≥‡∏£‡∏≠‡∏á‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ
        if (!fs.existsSync(backupFileDir)) {
            fs.mkdirSync(backupFileDir, { recursive: true });
        }
        
        fs.copyFileSync(filePath, backupFilePath);
        return backupFilePath;
    } catch (error) {
        console.warn(`‚ö†Ô∏è Cannot backup ${filePath}: ${error.message}`);
        return null;
    }
}

/**
 * ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÅ‡∏•‡∏∞‡∏•‡∏ö‡∏≠‡∏¥‡πÇ‡∏°‡∏à‡∏¥‡∏à‡∏≤‡∏Å‡πÄ‡∏ô‡∏∑‡πâ‡∏≠‡∏´‡∏≤‡πÑ‡∏ü‡∏•‡πå
 */
function removeEmojis(content) {
    let cleanContent = content;
    let emojiCount = 0;
    
    // ‡∏ô‡∏±‡∏ö‡πÅ‡∏•‡∏∞‡∏•‡∏ö‡∏≠‡∏¥‡πÇ‡∏°‡∏à‡∏¥
    EMOJI_PATTERNS.forEach(pattern => {
        const matches = cleanContent.match(pattern);
        if (matches) {
            emojiCount += matches.length;
            cleanContent = cleanContent.replace(pattern, '');
        }
    });
    
    return { 
        content: cleanContent, 
        emojiCount,
        changed: emojiCount > 0 
    };
}

/**
 * ‡∏•‡∏ö‡∏ö‡∏•‡πá‡∏≠‡∏Å‡∏Ñ‡∏≠‡∏°‡πÄ‡∏°‡∏ô‡∏ï‡πå‡∏ó‡∏µ‡πà‡∏°‡∏µ‡πÅ‡∏ï‡πà‡∏≠‡∏¥‡πÇ‡∏°‡∏à‡∏¥
 */
function removeEmojiComments(content, fileExt) {
    let commentCount = 0;
    let cleanContent = content;
    
    if (['.js', '.ts', '.jsx', '.tsx'].includes(fileExt)) {
        // ‡∏•‡∏ö single-line comments ‡∏ó‡∏µ‡πà‡∏°‡∏µ‡πÅ‡∏ï‡πà‡∏≠‡∏¥‡πÇ‡∏°‡∏à‡∏¥
        const singleLinePattern = /\/\/\s*[\u{1F000}-\u{1FAFF}\u{2600}-\u{27BF}\u{1F100}-\u{1F1FF}\u{2B00}-\u{2BFF}\s]*$/gmu;
        const singleMatches = cleanContent.match(singleLinePattern);
        if (singleMatches) {
            commentCount += singleMatches.length;
            cleanContent = cleanContent.replace(singleLinePattern, '');
        }
        
        // ‡∏•‡∏ö multi-line comments ‡∏ó‡∏µ‡πà‡∏°‡∏µ‡πÅ‡∏ï‡πà‡∏≠‡∏¥‡πÇ‡∏°‡∏à‡∏¥
        const multiLinePattern = /\/\*[\s\u{1F000}-\u{1FAFF}\u{2600}-\u{27BF}\u{1F100}-\u{1F1FF}\u{2B00}-\u{2BFF}]*\*\//gmu;
        const multiMatches = cleanContent.match(multiLinePattern);
        if (multiMatches) {
            commentCount += multiMatches.length;
            cleanContent = cleanContent.replace(multiLinePattern, '');
        }
    } else if (fileExt === '.html') {
        // ‡∏•‡∏ö HTML comments ‡∏ó‡∏µ‡πà‡∏°‡∏µ‡πÅ‡∏ï‡πà‡∏≠‡∏¥‡πÇ‡∏°‡∏à‡∏¥
        const htmlCommentPattern = /<!--[\s\u{1F000}-\u{1FAFF}\u{2600}-\u{27BF}\u{1F100}-\u{1F1FF}\u{2B00}-\u{2BFF}]*-->/gmu;
        const htmlMatches = cleanContent.match(htmlCommentPattern);
        if (htmlMatches) {
            commentCount += htmlMatches.length;
            cleanContent = cleanContent.replace(htmlCommentPattern, '');
        }
    }
    
    return { content: cleanContent, commentCount };
}

/**
 * ‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡πÅ‡∏•‡∏∞‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡πÑ‡∏ü‡∏•‡πå
 */
function analyzeFile(filePath, isDryRun = false, verbose = false, createBackup = false, backupDir = null, originalRoot = null) {
    try {
        const content = fs.readFileSync(filePath, 'utf8');
        const fileExt = path.extname(filePath).toLowerCase();
        
        // ‡∏•‡∏ö‡∏≠‡∏¥‡πÇ‡∏°‡∏à‡∏¥
        const emojiResult = removeEmojis(content);
        
        // ‡∏•‡∏ö‡∏Ñ‡∏≠‡∏°‡πÄ‡∏°‡∏ô‡∏ï‡πå‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏≠‡∏¥‡πÇ‡∏°‡∏à‡∏¥
        const commentResult = removeEmojiComments(emojiResult.content, fileExt);
        
        const totalChanges = emojiResult.emojiCount + commentResult.commentCount;
        const finalContent = commentResult.content;
        
        if (verbose || totalChanges > 0) {
            const fileName = path.basename(filePath);
            if (isDryRun) {
                console.log(`üîç Analyzing: ${path.relative(process.cwd(), filePath)}`);
                if (totalChanges > 0) {
                    console.log(`üìã ${fileName}: ${emojiResult.emojiCount} emojis, ${commentResult.commentCount} comments`);
                    if (verbose) {
                        console.log(`   Emojis: ${emojiResult.emojiCount}`);
                        console.log(`   Comments: ${commentResult.commentCount}`);
                    }
                } else {
                    console.log(`‚ú® No emojis found in ${fileName}`);
                }
            } else {
                console.log(`üîß Processing: ${path.relative(process.cwd(), filePath)}`);
                console.log(`‚úÖ ${fileName}: ${emojiResult.emojiCount} emojis, ${commentResult.commentCount} comments`);
            }
        }
        
        // ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÅ‡∏õ‡∏•‡∏á (‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà dry-run)
        if (!isDryRun && totalChanges > 0) {
            // ‡∏™‡∏≥‡∏£‡∏≠‡∏á‡πÑ‡∏ü‡∏•‡πå‡∏ñ‡πâ‡∏≤‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£
            if (createBackup && backupDir && originalRoot) {
                backupFile(filePath, backupDir, originalRoot);
            }
            
            fs.writeFileSync(filePath, finalContent, 'utf8');
        }
        
        return {
            processed: true,
            emojiCount: emojiResult.emojiCount,
            commentCount: commentResult.commentCount,
            changed: totalChanges > 0
        };
        
    } catch (error) {
        console.error(`‚ùå Error analyzing ${filePath}: ${error.message}`);
        return {
            processed: false,
            emojiCount: 0,
            commentCount: 0,
            changed: false,
            error: error.message
        };
    }
}

/**
 * ‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå
 */
function processDirectory(dirPath, isDryRun = false, verbose = false, extensions = ['.js', '.ts', '.jsx', '.tsx', '.html'], createBackup = false) {
    const startTime = Date.now();
    let totalFiles = 0;
    let filesWithEmojis = 0;
    let totalEmojis = 0;
    let totalComments = 0;
    let errors = 0;
    
    // ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå‡∏™‡∏≥‡∏£‡∏≠‡∏á‡∏ñ‡πâ‡∏≤‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£
    let backupDir = null;
    if (createBackup && !isDryRun) {
        backupDir = createBackupDir(dirPath);
        console.log(`üíæ Backup directory: ${backupDir}`);
    }
    
    function walkDir(dir) {
        try {
            const items = fs.readdirSync(dir);
            
            for (const item of items) {
                const itemPath = path.join(dir, item);
                
                try {
                    const stat = fs.statSync(itemPath);
                    
                    if (stat.isDirectory()) {
                        // ‡∏Ç‡πâ‡∏≤‡∏° backup folders
                        if (item.startsWith('backup-') || item.startsWith('emoji-backup-') || 
                            item === 'node_modules' || item === '.git' || item === 'dist' || item === 'build') {
                            if (verbose) {
                                console.log(`‚è≠Ô∏è Skipping: ${path.relative(process.cwd(), itemPath)}`);
                            }
                            continue;
                        }
                        walkDir(itemPath);
                    } else if (stat.isFile()) {
                        const fileExt = path.extname(itemPath).toLowerCase();
                        if (extensions.includes(fileExt)) {
                            totalFiles++;
                            const result = analyzeFile(itemPath, isDryRun, verbose, createBackup, backupDir, dirPath);
                            
                            if (result.processed) {
                                if (result.changed) {
                                    filesWithEmojis++;
                                }
                                totalEmojis += result.emojiCount;
                                totalComments += result.commentCount;
                            } else {
                                errors++;
                            }
                        }
                    }
                } catch (error) {
                    if (verbose) {
                        console.warn(`‚ö†Ô∏è Cannot access ${itemPath}: ${error.message}`);
                    }
                    errors++;
                }
            }
        } catch (error) {
            console.error(`‚ùå Cannot read directory ${dir}: ${error.message}`);
            errors++;
        }
    }
    
    walkDir(dirPath);
    
    const endTime = Date.now();
    const duration = ((endTime - startTime) / 1000).toFixed(2);
    
    return {
        totalFiles,
        filesWithEmojis,
        totalEmojis,
        totalComments,
        errors,
        duration,
        backupDir
    };
}

/**
 * ‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô
 */
function showHelp() {
    console.log(`
üìñ Universal Emoji Cleaner v2.0 - Usage Guide

SYNTAX:
  emoji-cleaner [target] [options]
  npx @chahuadev/emoji-cleaner [target] [options]

ARGUMENTS:
  target                Path to file or directory (default: current directory)

OPTIONS:
  -d, --dry-run        Preview changes without modifying files
  -v, --verbose        Show detailed information during processing
  -b, --backup         Create backup before making changes
  -h, --help           Show this help message
  --ext <extensions>   Specify file extensions (default: .js,.ts,.jsx,.tsx,.html)

EXAMPLES:
  emoji-cleaner                                    # Clean current directory
  emoji-cleaner /path/to/project                   # Clean specific project
  emoji-cleaner ./src --dry-run                    # Preview changes only
  emoji-cleaner --verbose --backup                 # Clean with backup and details
  emoji-cleaner --ext .js,.html                    # Only process specific files
  emoji-cleaner /path/to/file.js                   # Clean single file

FEATURES:
  ‚úÖ Unicode emoji detection and removal
  ‚úÖ Comment block cleanup (JS/TS/HTML)
  ‚úÖ Dry-run mode for safe preview
  ‚úÖ Automatic backup creation
  ‚úÖ Cross-platform compatibility
  ‚úÖ Works with any project structure

SUPPORTED FILES:
  üìÑ .js   - JavaScript files
  üìÑ .ts   - TypeScript files  
  üìÑ .jsx  - React JSX files
  üìÑ .tsx  - React TypeScript files
  üìÑ .html - HTML files

GLOBAL INSTALLATION:
  npm install -g @chahuadev/emoji-cleaner
  emoji-cleaner --help

PROJECT-SPECIFIC USAGE:
  npx @chahuadev/emoji-cleaner ./my-project
    `);
}

/**
 * ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏´‡∏•‡∏±‡∏Å
 */
function main() {
    const args = process.argv.slice(2);
    
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö help
    if (args.includes('-h') || args.includes('--help')) {
        showHelp();
        return;
    }
    
    let targetPath = process.cwd();
    let isDryRun = false;
    let verbose = false;
    let createBackup = false;
    let extensions = ['.js', '.ts', '.jsx', '.tsx', '.html'];
    
    // ‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå arguments
    for (let i = 0; i < args.length; i++) {
        const arg = args[i];
        
        if (arg === '-d' || arg === '--dry-run') {
            isDryRun = true;
        } else if (arg === '-v' || arg === '--verbose') {
            verbose = true;
        } else if (arg === '-b' || arg === '--backup') {
            createBackup = true;
        } else if (arg === '--ext') {
            if (i + 1 < args.length) {
                extensions = args[i + 1].split(',').map(ext => ext.trim());
                i++; // ‡∏Ç‡πâ‡∏≤‡∏° argument ‡∏ñ‡∏±‡∏î‡πÑ‡∏õ
            }
        } else if (!arg.startsWith('-')) {
            // Path argument
            const inputPath = path.resolve(arg);
            if (fs.existsSync(inputPath)) {
                targetPath = inputPath;
            } else {
                console.error(`‚ùå Path not found: ${inputPath}`);
                process.exit(1);
            }
        }
    }
    
    console.log('üßπ Universal Emoji Cleaner v2.0');
    console.log('================================');
    if (isDryRun) {
        console.log('üîç DRY RUN MODE - No files will be modified');
    }
    console.log(`üéØ Target: ${path.relative(process.cwd(), targetPath)}`);
    console.log(`üìÅ Extensions: ${extensions.join(', ')}`);
    
    if (createBackup && !isDryRun) {
        console.log('üíæ Backup mode enabled');
    }
    
    console.log('');
    
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÄ‡∏õ‡πá‡∏ô‡πÑ‡∏ü‡∏•‡πå‡∏´‡∏£‡∏∑‡∏≠‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå
    const stat = fs.statSync(targetPath);
    
    if (stat.isFile()) {
        // ‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡πÑ‡∏ü‡∏•‡πå‡πÄ‡∏î‡∏µ‡∏¢‡∏ß
        const fileExt = path.extname(targetPath).toLowerCase();
        if (!extensions.includes(fileExt)) {
            console.error(`‚ùå File extension ${fileExt} not supported`);
            console.log(`Supported extensions: ${extensions.join(', ')}`);
            process.exit(1);
        }
        
        const result = analyzeFile(targetPath, isDryRun, verbose, createBackup);
        
        console.log('================================');
        if (isDryRun) {
            console.log('üîç Analysis Complete!');
        } else {
            console.log('üéâ Cleaning Complete!');
        }
        console.log(`üìä Emojis ${isDryRun ? 'found' : 'removed'}: ${result.emojiCount}`);
        console.log(`üí¨ Comments ${isDryRun ? 'found' : 'removed'}: ${result.commentCount}`);
        
    } else {
        // ‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå
        const results = processDirectory(targetPath, isDryRun, verbose, extensions, createBackup);
        
        console.log('================================');
        if (isDryRun) {
            console.log('üîç Analysis Complete!');
        } else {
            console.log('üéâ Cleaning Complete!');
        }
        console.log(`üìä Files ${isDryRun ? 'with emojis' : 'processed'}: ${results.filesWithEmojis}`);
        console.log(`üîß Total emojis ${isDryRun ? 'found' : 'removed'}: ${results.totalEmojis}`);
        console.log(`üí¨ Comments ${isDryRun ? 'with emojis' : 'removed'}: ${results.totalComments}`);
        
        if (results.errors > 0) {
            console.log(`‚ö†Ô∏è Errors encountered: ${results.errors}`);
        }
        
        if (results.backupDir) {
            console.log(`üíæ Backup saved to: ${path.relative(process.cwd(), results.backupDir)}`);
        }
        
        if (isDryRun) {
            console.log('üí° Use without --dry-run to apply changes');
        }
        console.log(`‚è±Ô∏è Time taken: ${results.duration}s`);
    }
}

// ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà‡∏Å‡∏≤‡∏£ import
if (require.main === module) {
    main();
}

module.exports = {
    removeEmojis,
    analyzeFile,
    processDirectory,
    main
};
